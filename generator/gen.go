package main

import (
	"fmt"
	"time"

	. "github.com/dave/jennifer/jen"
)

func generate() error {

	modules, err := get_modules()
	if err != nil {
		return err
	}

	modules = append(modules)

	moduleToCommandInfo := make(map[string][][]string)
	for _, module := range modules {
		moduleCommands, err := get_commands_for_module(module)
		if err != nil {
			return err
		}
		moduleToCommandInfo[module] = moduleCommands
	}

	file := NewFile("main")

	file.Comment(fmt.Sprintf("DO NOT EDIT; AUTOGENERATED ON %s", time.Now().Format(time.ANSIC)))

	file.Const().Defs(
		Id("OrcaServiceName").Op("=").Lit(OrcaServiceName),
		Id("OrcaObjectPath").Op("=").Lit(OrcaObjectPath),
	)

	var structFields []Code

	for module := range moduleToCommandInfo {
		structField := Id(module).Id(module)

		structFields = append(structFields, structField)
	}

	file.Type().Id("OrcaClient").Struct(
		append([]Code{Id("conn").Op("*").Qual("github.com/godbus/dbus/v5", "Conn")}, structFields...)...,
	)

	for module, commandInfo := range moduleToCommandInfo {

		file.Type().Id(module).Struct(
			Id("conn").Op("*").Qual("github.com/godbus/dbus/v5", "Conn"),
		)

		for _, cmd := range commandInfo {
			functionName := cmd[0]
			functionDescription := cmd[1]
			file.Comment(functionDescription)
			file.Func().
				Params(
					Id("c").Op("*").Id(module),
				).Id(functionName).Call().Error().Block(
				Id("obj").Op(":=").Id("c").Dot("conn").Dot("Object").Call(
					Lit(OrcaServiceName),
					Lit(OrcaObjectPath+"/"+module),
				),
				Var().Id("succeeded").Id("bool"),
				Id("err").Op(":=").Id("obj").Dot("Call").Call(
					Lit(OrcaCallMethod),
					Lit(0),
				).Dot("Store").Call(Op("&").Id("succeeded")),
				If(Id("err").Op("!=").Nil()).Block(
					Return(Id("err")),
				),
				If(Id("!succeeded")).Block(
					Return(Call(
						Qual("errors", "New").Call(Lit("command failed")))),
				),
				Return(Nil()),
			)

		}

	}

	return file.Save("client.go")
}

func main() {
	if err := generate(); err != nil {
		panic(err)
	}
}
